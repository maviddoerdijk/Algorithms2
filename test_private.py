import typing
import unittest
import numpy as np
import time

from divconq import IntelDevice


class TestIntelDevice(unittest.TestCase):
   
    def test_small_matrix(self):

        arr_list = [] # List of nxn arrays self.arr_list[n]
        for n in range(0, 11):
            arr = np.zeros((n, n), dtype=int)
            for i in range(n):
                for j in range(n):
                    arr[i, j] = i*n + j + 1
            arr_list.append(arr)
        a = arr_list[3]

        cities = ['1001110 1011001 1000011', '1001100 1000001 1011000', '1010011 1000110 1001111', '1001111 1010010 1000100', '1000100 1000110 1010111', '1001101 1001001 1000001', '1001100 1000001 1010011', '1010000 1001000 1011000', '1000011 1001100 1010100', '1010011 1000101 1000001', '1000100 1000101 1001110', '1001101 1000011 1001111', '1000101 1010111 1010010', '1001001 1000001 1001000', '1000010 1001111 1010011', '1010011 1001100 1000011', '1000110 1001100 1001100', '1000100 1000011 1000001', '1001101 1010011 1010000', '1000100 1010100 1010111', '1010100 1010000 1000001', '1010000 1000100 1011000', '1001000 1001110 1001100', '1010011 1000001 1001110', '1000010 1010111 1001001', '1010011 1010100 1001100', '1001111 1000001 1001011', '1010011 1001101 1000110', '1010011 1001010 1000011', '1000010 1010101 1010010', '1001111 1001110 1010100', '1010011 1001110 1000001', '1001100 1000111 1000010', '1010000 1010011 1010000', '1000010 1001111 1001001', '1000001 1000010 1010001', '1010100 1010101 1010011']
        enc_locations = cities[:9]

        codes_total = ['110001', '110010', '110011', '110100', '110101', '110110', '110111', '111000', '111001', '110001 110000', '110001 110001', '110001 110010', '110001 110011', '110001 110100', '110001 110101', '110001 110110', '110001 110111', '110001 111000', '110001 111001', '110010 110000', '110010 110001', '110010 110010', '110010 110011', '110010 110100', '110010 110101', '110010 110110', '110010 110111', '110010 111000', '110010 111001', '110011 110000', '110011 110001', '110011 110010', '110011 110011', '110011 110100', '110011 110101', '110011 110110']

        enc_codes = codes_total[:9]

        solutions = cities[:9]
        
        ob = IntelDevice(3,3, enc_locations, enc_codes, 0)

        ob.fill_coordinate_to_loc()
        ob.fill_loc_grid()


        for vid, v in enumerate(a.reshape(-1)):
            if v == 20:
                continue
            result = ob.start_search(v)
            self.assertEqual(result, solutions[vid])


    def test_medium_matrix(self):
        arr_list = [] # List of nxn arrays -> self.arr_list[n] is an nxn matrix 
        for n in range(0, 11):
            arr = np.zeros((n, n), dtype=int)
            for i in range(n):
                for j in range(n):
                    arr[i, j] = i*n + j + 1
            arr_list.append(arr)
        a = arr_list[4]

        cities = ['1001110 1011001 1000011', '1001100 1000001 1011000', '1010011 1000110 1001111', '1001111 1010010 1000100', '1000100 1000110 1010111', '1001101 1001001 1000001', '1001100 1000001 1010011', '1010000 1001000 1011000', '1000011 1001100 1010100', '1010011 1000101 1000001', '1000100 1000101 1001110', '1001101 1000011 1001111', '1000101 1010111 1010010', '1001001 1000001 1001000', '1000010 1001111 1010011', '1010011 1001100 1000011', '1000110 1001100 1001100', '1000100 1000011 1000001', '1001101 1010011 1010000', '1000100 1010100 1010111', '1010100 1010000 1000001', '1010000 1000100 1011000', '1001000 1001110 1001100', '1010011 1000001 1001110', '1000010 1010111 1001001', '1010011 1010100 1001100', '1001111 1000001 1001011', '1010011 1001101 1000110', '1010011 1001010 1000011', '1000010 1010101 1010010', '1001111 1001110 1010100', '1010011 1001110 1000001', '1001100 1000111 1000010', '1010000 1010011 1010000', '1000010 1001111 1001001', '1000001 1000010 1010001', '1010100 1010101 1010011']
        enc_locations = cities[:16]

        codes_total = ['110001', '110010', '110011', '110100', '110101', '110110', '110111', '111000', '111001', '110001 110000', '110001 110001', '110001 110010', '110001 110011', '110001 110100', '110001 110101', '110001 110110', '110001 110111', '110001 111000', '110001 111001', '110010 110000', '110010 110001', '110010 110010', '110010 110011', '110010 110100', '110010 110101', '110010 110110', '110010 110111', '110010 111000', '110010 111001', '110011 110000', '110011 110001', '110011 110010', '110011 110011', '110011 110100', '110011 110101', '110011 110110']

        enc_codes = codes_total[:16]

        solutions = cities[:16]
        
        ob = IntelDevice(4,4, enc_locations, enc_codes, 0)
        ob.fill_coordinate_to_loc()
        ob.fill_loc_grid()


        for vid, v in enumerate(a.reshape(-1)):
            if v == 20:
                continue
            result = ob.start_search(v)
            self.assertEqual(result, solutions[vid])



   

    def print_encoder(self):

        enc_loc = [
            "1101110 110010",
            "1101110 110011",
            "1101110 110100",
            "1101110 110101",
            "1101110 110110",
            "1101110 110111",
            "1101110 111000",
            "1101110 111001",
            "1101110 111010",
            "1101110 111011",
            "1101110 110011 110010",
            "1101110 110011 110011"
        ]

        enc_code = [
            "110011",
            "110011 110010",
            "110101 110010",
            "110111 110011",
            "110011 111000",
            "110100 110010",
            "110110 110100",
            "110111 110100",
            "110101 110100",
            "110110 111001",
            "110111 111001",
            "111010 110010",
        ]

        
        solutions = [
            "1101110 110010",
            "1101110 110011",
            "1101110 110100",
            "1101110 110101",
            "1101110 110110",
            "1101110 110111",
            "1101110 111000",
            "1101110 111001",
            "1101110 111010",
            "1101110 111011",
            "1101110 110011 110010",
            "1101110 110011 110011"
        ]
        ob = IntelDevice(5,5, enc_loc, enc_code, 0)

        for string in enc_loc:
            translation = ob.decode_message(string)
            print(f"{string} means {translation} a location")

        for string in enc_code:
            translation = ob.decode_message(string)
            print(f"{string} means {translation} a code")

        for string in solutions:
            translation = ob.decode_message(string)
            print(f"{string} means {translation} a solution")  
        
        davidstring = []
        cities = ['NYC', 'LAX', 'SFO', 'ORD', 'DFW', 'MIA', 'LAS', 'PHX', 'CLT', 'SEA', 'DEN', 'MCO', 'EWR', 'IAH', 'BOS', 'SLC', 'FLL', 'DCA', 'MSP', 'DTW', 'TPA', 'PDX', 'HNL', 'SAN', 'BWI', 'STL', 'OAK', 'SMF', 'SJC', 'BUR', 'ONT', 'SNA', 'LGB', 'PSP', 'BOI','ABQ','TUS']
        
        for i in range(1,37):
            msg = ob.encode_message(f'{i}')
            davidstring.append(msg)
        print(davidstring, 'finderr')


    def test_big_matrix(self):
        arr_list = [] # List of nxn arrays self.arr_list[n]
        for n in range(0, 11):
            arr = np.zeros((n, n), dtype=int)
            for i in range(n):
                for j in range(n):
                    arr[i, j] = i*n + j + 1
            arr_list.append(arr)
        a = arr_list[5]

        cities = ['1001110 1011001 1000011', '1001100 1000001 1011000', '1010011 1000110 1001111', '1001111 1010010 1000100', '1000100 1000110 1010111', '1001101 1001001 1000001', '1001100 1000001 1010011', '1010000 1001000 1011000', '1000011 1001100 1010100', '1010011 1000101 1000001', '1000100 1000101 1001110', '1001101 1000011 1001111', '1000101 1010111 1010010', '1001001 1000001 1001000', '1000010 1001111 1010011', '1010011 1001100 1000011', '1000110 1001100 1001100', '1000100 1000011 1000001', '1001101 1010011 1010000', '1000100 1010100 1010111', '1010100 1010000 1000001', '1010000 1000100 1011000', '1001000 1001110 1001100', '1010011 1000001 1001110', '1000010 1010111 1001001', '1010011 1010100 1001100', '1001111 1000001 1001011', '1010011 1001101 1000110', '1010011 1001010 1000011', '1000010 1010101 1010010', '1001111 1001110 1010100', '1010011 1001110 1000001', '1001100 1000111 1000010', '1010000 1010011 1010000', '1000010 1001111 1001001', '1000001 1000010 1010001', '1010100 1010101 1010011']
        enc_locations = cities[:25]

        codes_total = ['110001', '110010', '110011', '110100', '110101', '110110', '110111', '111000', '111001', '110001 110000', '110001 110001', '110001 110010', '110001 110011', '110001 110100', '110001 110101', '110001 110110', '110001 110111', '110001 111000', '110001 111001', '110010 110000', '110010 110001', '110010 110010', '110010 110011', '110010 110100', '110010 110101', '110010 110110', '110010 110111', '110010 111000', '110010 111001', '110011 110000', '110011 110001', '110011 110010', '110011 110011', '110011 110100', '110011 110101', '110011 110110']

        enc_codes = codes_total[:25]

        solutions = cities[:25]
        

        ob = IntelDevice(5,5, enc_locations, enc_codes, 0)
        ob.fill_coordinate_to_loc()
        ob.fill_loc_grid()


        for vid, v in enumerate(a.reshape(-1)):
            if v == 20:
                continue
            result = ob.start_search(v)
            self.assertEqual(result, solutions[vid])

        # values that do not occur should lead to None
        for v in [0,48,60,72]:
            result = ob.start_search(v)
            self.assertIsNone(result)

# Printing things, by running this file:
if __name__ == '__main__':
    t = TestIntelDevice()
    # t.print_encoder()
    # t.create_arrays()
    t.create_arrays()
    # t.private_test1()
    t.small_matrix()
